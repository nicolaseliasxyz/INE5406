library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use ieee.NUMERIC_STD.all;

entity ULA is
    Port (
    A, B     : in  STD_LOGIC_VECTOR(7 downto 0);
    ULA_Sel  : in  STD_LOGIC_VECTOR(3 downto 0);
    clk, clk_raiz, clk_mult, Reset,i nicio_mult, inicio_raiz: in STD_LOGIC;
    prontoraiz, prontomult   : out STD_LOGIC;
    ULA_Out_Mult   : out  STD_LOGIC_VECTOR(15 downto 0);
    ULA_Out_Result   : out  STD_LOGIC_VECTOR(7 downto 0);
    conteudoA,conteudoB: out STD_LOGIC_VECTOR(7 DOWNTO 0));
end ULA; 
architecture Behavioral of ULA is

    component multiplicador is
        port ( Reset, clk, inicio : in std_logic;
                entA, entB : in std_logic_vector(7 downto 0);
                pronto : out std_logic;
                conteudoA, conteudoB: out std_logic_vector(7 downto 0);
                saida: out std_logic_vector(15 downto 0));
    end component;

    component raiz is
        port (entrada: in std_logic_vector(7 downto 0);
          inicio, reset, clk: in std_logic;
          saida: out std_logic_vector(7 downto 0);
          pronto: out std_logic);
    end component;

    component muxula11x1 is
        PORT (soma, sub, amais, amenos, nota, aandb, aorb, axorb, mult, raiz, halt : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
            sel: IN STD_LOGIC;
            y : OUT STD_LOGIC_VECTOR(7 DOWNTO 0));
  END component;

signal ULA_Result, Result_Raiz  : std_logic_vector (7 downto 0);
signal ULA_Result_Mult, Result_Mult : std_logic_vector (15 downto 0);
signal soma, soma, amais, amenos, nota, aandb, aorb, axorb, mult, raiz, halt: std_logic_vector (7 downto 0);
begin

    MULT1: multiplicador port map (entA => A,
                                   entB => B,
                                   clk => clk_mult,
                                   inicio => inicio_mult,
                                   reset => Reset,
                                   conteudoA => conteudoA,
                                   conteudoB => conteudoB,
                                   saida => Result_Mult,
                                   pronto => prontomult);

    RAIZ1: raiz port map(entrada => A,
                        inicio => inicio_raiz,
                        reset => Reset,
                        clk => clk_raiz,
                        pronto => prontoraiz,
                        saida => Result_Raiz);

    MUX11P1: muxula11x1 port map(soma => soma;
                                sub => sub;
                                amais => amais;
                                amenos => amenos;
                                nota => nota;
                                aandb => aandb;
                                aorb => aorb;
                                axorb => axorb;
                                mult <= mult;
                                raiz <= raiz;
                                halt <= NULL
                                y => ULA_Result);

    soma <= A + B;
    sub <= A - B;
    amais <= A + "00000001";
    amenos <= A - "00000001";
    nota <= NOT(A);
    aandb <= A AND B;
    aorb <= A OR B;
    axorb <= A XOR B;
    mult <= Result_Mult;
    raiz <= Result_Raiz;
    halt <= NULL;

    --//Processo do monociclo para atualização da saida caso ULA_Sel seja uma multiplicacao ou uma raiz
    PROCESS (clk)
    BEGIN
    if (clk'EVENT AND clk = '1') then
        ULA_Out_Mult <= Result_Mult;
        ULA_Out_Result <= ULA_Result;
    end if;
    end process;
end Behavioral;